# 操作系统

## Overview

> 2023 / 09 / 19

### Definition

计算机用户和计算机硬件之间的中介程序。

A resource allocator, a control program.

### Startup

此时需要 **bootstrap program** 初始化操作系统并加载。通常被存储在 ROM 或 EPROM 中，也叫做 firmware。

### Trap

软中断。由程序错误 (error，例如，除零) 或者用户请求引发 (system call)。

中断分为两种，硬中断 (H/W)，软中断。

为何使用软中断：

+ 封装内存代码，方便调用。
+ 可以对多个 users 的不同操作进行管理与协调。

在 RISC-V 中，所有的中断都称为 traps，分为两类 interrupts (硬中断)，exceptions (异常) & ecalls (环境调用) (即软中断)。

### I / O

同步 (blocked，阻塞)：I / O 设备发起后，用户的进程将不再进行。

异步 (non-block，非阻塞)：尝试读取 I / O 设备状态，但用户程序不会完全中断。

<img src="./操作系统.assets/image-20230921105511504.png" alt="image-20230921105511504" style="zoom:33%;" />

**Device-Status Table**

<img src="./操作系统.assets/image-20230921110624264.png" alt="image-20230921110624264" style="zoom:33%;" />

决定以何种顺序处理多个请求。

### Multiprocessor / Multicore System

多处理器：共享主存。

多核处理器：共享 L2 缓存。

**NUMA**

The CPUs are connected by a shared system interconnect.

<img src="./操作系统.assets/image-20230921112750594.png" alt="image-20230921112750594" style="zoom:33%;" />

### 操作系统结构

**multiprogramming**：可以将多个程序存入主存进行运行，提高 CPU 的利用率。多道程序设计。

**timesharing (multitasking)**：多用户同时分享 CPU 资源，并可以得到相对应的相应。分时系统。

+ 使用 CPU scheduling 规划多程序同时运行。
+ 使用 Swapping 使得大规模的程序 (大于内存空间)，可以运行。
+ 使用 virtual memory 可以程序不完全在内存中运行。

操作系统会有两个 mode。如 User mode 和 kernel mode，用硬件上的一些 bits 进行表征。

+ 一些特权指令只能在 kernel mode 下运行。
+ 两种 mode 进行了隔离，不能同时处在两种状态。

以下为两种模式之间的切换步骤：

<img src="./操作系统.assets/image-20230926164842887.png" alt="image-20230926164842887" style="zoom:33%;" />

call system call 是一种软中断，也称 trap。实际上为程序为用户态提供了一系列的 API。

### 进程管理

进程是指一个程序的执行。程序是一个被动的实体，进程是一个积极的实体。

进程是资源的集合：CPU、内存、I/O、文件、程序的状态数据。

进程又可以分为多个线程，每个线程都会有一个 Program Counter。

CPU 的复用，指的就是多个程序并发地运行。可以分为时分复用和空分复用。

进程种需要解决许多问题，如：进程的同步、交流、创建、删除、防止死锁等。

### 内存管理

**一般情况下**，在运行程序时，数据和指令都需要在内存之中。

进程管理的内容：记录内存的使用状态、内存分配与回收、决定各个进程的内存使用。

### 储存管理

操作系统提供了统一、逻辑的信息存储视图。

储存的单元为文件，每种存储介质均被设备管理。

文件系统中：

+ 可以使用目录结构进行管理。
+ 进行文件访问的管理与控制。

大文件管理中：

+ 通常使用硬盘进行存储。
+ 由操作系统进行管理，进行存储分配和磁盘调度。操作系统的运行速度高度依赖于磁盘调度算法。



==操作系统的目的：抽象 (系统调用)、复用、隔离、共享 (多进程、多用户)、安全、性能、功能==



## OS 结构

> 2023 / 09 / 26

### OS Services

+ **User interface** (UI)：分为 GUI 和 CLI。
+ **Program execution**：包括用户程序和系统程序，能够处理报错。
+ I / O、File system、错误处理、资源分配……

### System Calls

用户模式进入系统模式的唯一方式，trap。

相较 API (Application Program Interface)，system call 更加底层。

POSIX API：Unix、Linux、MacOS 的通用标准，提供系统调用接口。

每种 system call 会被编号。被记录在一张表中，放在 system-call interface。

User 中调用：

<img src="./操作系统.assets/image-20230928102417019.png" alt="image-20230928102417019" style="zoom:33%;" />

高级语言中调用：

<img src="./操作系统.assets/image-20230928102508808.png" alt="image-20230928102508808" style="zoom:33%;" />

都是通过某个 interface 实现状态转换。

内核中 system call 的具体实现向上层封装，可以增加其可移植性。

**参数传递**

+ 寄存器传递，最为简单的方式。

+ 参数较多时，可以存在一个内存中的 Block 或者 table 中，将 Block 或 table 的地址通过寄存器传递。需要注意的是可能传递的地址为虚地址 (两种态之间的传递)，需要经过转换。

  <img src="./操作系统.assets/image-20230928104004988.png" alt="image-20230928104004988" style="zoom:33%;" />

+ 通过栈进行传递。但是栈在两种态下不一定能够共享，该方法不适用于所有的系统。

**分类**：进程管理 (创建 child pid-等待-退出)、文件管理、设备管理、信息维护 (如获取 pid)、交流、权限保护。

### 操作系统的设计和实现

设计的原则：What will be done? 策略 Policy。How to do it? 机制 Mechanism。需要将 Policy 和 Mechanism 分离。

#### 分层结构

<img src="./操作系统.assets/image-20230928112758073.png" alt="image-20230928112758073" style="zoom:33%;" />

但这只是概念模型，实际上不同层级之间仍存在嵌套。

以下为 UNIX 的系统分层概念图。

<img src="./操作系统.assets/image-20230928113038305.png" alt="image-20230928113038305" style="zoom:33%;" />

UNIX 为宏内核结构。对应的微内核 (仅实现基本的功能)，示意如下：

<img src="./操作系统.assets/image-20230928113247686.png" alt="image-20230928113247686" style="zoom:33%;" />

相比宏内核，许多程序需要在 User Mode 中实现。微内核有时需要通过进程通讯实现操作，效率相比宏内核可能降低。但微内核较为稳定、容易移植等。

现代的操作系统也会使用**内核模块 (LKM)** 这种机制 (Linux 为宏内核，但采用了模块化 + 动态加载的机制)。

<img src="./操作系统.assets/image-20231007102521225.png" alt="image-20231007102521225" style="zoom:33%;" />

可以在需要使用时加载对应的模块到 kernel。

**Exokernel**：外核，内核高度简化，只负责资源分配和低级的硬件操作，必须使用定制的库供上层应用使用。

<img src="./操作系统.assets/image-20231007102846989.png" alt="image-20231007102846989" style="zoom:33%;" />

与微内核的区别在于，通过库而不是消息传递进行程序调用。存在兼容性问题，对于定制库文件不统一，维护难度较高。

### 虚拟机

<img src="./操作系统.assets/image-20231007104630519.png" alt="image-20231007104630519" style="zoom:33%;" />

virtual-machine implementation，也称 hypervisor。

两种虚拟机的方案：Type 1 (bare-metal，虚拟机直接和硬件交互)，type 2 (host，虚拟机依赖于宿主系统)



## 进程

> 2023 / 10 / 07

### 概念

进程：一个正在执行的程序，且需要是被顺序执行。

一个进程由以下几个 sections 组成：

+ text section (程序段、代码段)
+ data section (全局变量)
+ program counter
+ 栈 stack (函数参数、局部变量、返回地址) (地址从高到低)
+ 堆 heap (动态分配的内存) (地址从低到高)

<img src="./操作系统.assets/image-20231007112213993.png" alt="image-20231007112213993" style="zoom:25%;" />

此处的地址为虚拟地址而非物理地址。实际上进程所使用的空间，只有 max 端以及 0 段一小部分的空间，中间大部分不用的空间称为 hole。

==user code 和 kernel 不使用同一个 stack，每个进程都有自己对应的 stacks，以获得更好的隔离性==

### 状态

一个进程有以下几种状态：

+ new：正在被创建
+ running：指令正在被执行
+ waiting：进程在等待 (或 blocked) 一些事件 / 响应 (例如等待键盘响应、磁盘操作完成)
+ ready：进程等待**处理器**进行处理 (可能 CPU 处于非空闲状态)
+ terminate：任务完成

<img src="./操作系统.assets/image-20231007113439065.png" alt="image-20231007113439065" style="zoom:33%;" />

### Process control block (PCB)

需要记录进程的状态、调度以及其他重要信息 (现场)。

PCB 需要创建一种数据结构，其中具体需要记录的部分信息有：Process state、Program counter、Contents of CPU registers、CPU scheduling information、Memory-management information、Accounting information、I/O status information

<img src="./操作系统.assets/image-20231010164426557.png" alt="image-20231010164426557" style="zoom:33%;" />

进程调度时需要保存进程的上下文，使等待结束后的进程可以正常运行。

<img src="./操作系统.assets/image-20231010164745479.png" alt="image-20231010164745479" style="zoom:33%;" />

PCB 存储在 kernel stack 中。

#### 调度队列 Process Scheduling Queues

+ 任务队列 **Job queue** – set of all processes in the system

+ 就绪队列 **Ready queue** – set of all processes residing in main memory, ready and waiting to execute

+ 设备队列 **Device queues** – set of processes waiting for an I/O device，可能会有多个，每个设备对应一个队列

<img src="./操作系统.assets/image-20231010170024599.png" alt="image-20231010170024599" style="zoom:33%;" />

ready queue 实际上也是 CPU queue。

一个 PCB 一次只能出现在一个队列上。程序被顺序执行，而程序要使用 device 只能使用 system call。

一个进程被 timer interrupt 打断，会被重新放入 ready queue。

Job queue 会链接所有的进程，上图中未绘出。

进程会在 queue 之间迁移 migrate。

<img src="./操作系统.assets/image-20231010172530563.png" alt="image-20231010172530563" style="zoom:33%;" />

#### Schedulers

+ **Long-term scheduler** (or job scheduler) – selects which processes should be brought into memory (the ready queue)
+ **Short-term scheduler** (or CPU scheduler) – selects which process should be executed next and allocates CPU

当下，用户取代了 long-term scheduler 的角色。

<img src="./操作系统.assets/image-20231010172855018.png" alt="image-20231010172855018" style="zoom:33%;" />

一般考虑 short-term。

进程 schedule 的速度需要尽量快以减少进程调用的 overhead 时间。

此外还有 **medium-term scheduling**，也称 **swap-in, swap-out**。当内存中的进程占用的空间过多时，需要对内存进行管理。

<img src="./操作系统.assets/image-20231010173343011.png" alt="image-20231010173343011" style="zoom:33%;" />

short-term scheduler 调用非常频繁。约 10 ms 就需要 timer interrupt 进行调度，是为了保证良好的交互性。

+ I/O 绑定，**I/O-bound process** – spends more time doing I/O than computations, many short CPU bursts

+ CPU 绑定，**CPU-bound process** – spends more time doing computations; few very long CPU bursts

#### Context Switch

上下文切换，切换不同的进程。

上下文切换时会 overhead，此时系统不可用。

### 进程创建

父进程可以创建子进程，子进程还可以创建自己的子进程，会形成一颗进程树。

+ 父进程和子进程之间可以选择共享资源的范围 (从共享全部资源到不共享)。

+ 父进程和子进程可能并发进行也可能父进程等待子进程完成。
+ 子进程和父进程的地址空间可能是复制关系 (Linux)，也可以由程序加载。

在 UNIX 中：

+ **fork** system call creates new process

+ **exec** system call used after a **fork** to replace the process’ memory space with a new program

<img src="./操作系统.assets/image-20231012104017049.png" alt="image-20231012104017049" style="zoom:33%;" />

父进程的 pid 为 1 的进程称为 orphan 进程。

一个 fork 的例子如下：

~~~c++
int main()
{
	pid_t  pid;
	/* fork another process */
	pid = fork();
	if (pid < 0) { /* error occurred */
		fprintf(stderr, "Fork Failed");
		exit(-1);
	}
	else if (pid == 0) { /* child process */
		execlp("/bin/ls", "ls", NULL);
	}
	else { /* parent process */
		/* parent will wait for the child 	to complete */
		wait (NULL);
		printf ("Child Complete");
		exit(0);
	}
}
~~~

一个进程树的示意如下：

<img src="./操作系统.assets/image-20231012111048874.png" alt="image-20231012111048874" style="zoom:33%;" />

### 进程终止

分为 exit 和 abort，根据不同的操作系统设计，父进程可能会影响子进程的运行。(linux 不影响)

### 进程的合作与通信

进程通信可以实现信息共享、计算加速、模块化设计。

**Producer-Consumer Problem**

producer process 生产信息，由 consumer process 使用，需要通过 buffer 实现信息的传递。

+ unbounded-buffer：传递信息远小于 buffer 空间。
+ bounded-buffer：buffer 的空间可能会被完全使用。

~~~c++
// shared data
#define BUFFER_SIZE 10
typedef struct {
	. . .
} item;

item buffer[BUFFER_SIZE];
int in = 0;
int out = 0;


// producer / insert
while (true) {   
    Produce an item;
    while (((in + 1) % BUFFER_SIZE == out){}
    /* do nothing -- no free buffers */
    buffer[in] = item;
    in = (in + 1) % BUFFER_SIZE;
}

// consumer / remove
while (true) {
    while (in == out){} //do nothing, nothing to consume
    Remove an item from the buffer;
    item = buffer[out];
    out = (out + 1) % BUFFER_SIZE;
    return item;
}
~~~

**Interprocess Communication IPC**

有两种方式：shared memory 和 message passing。

<img src="./操作系统.assets/image-20231017165122104.png" alt="image-20231017165122104" style="zoom:33%;" />

对于 message passing 这一方式，可以分为 Direct Communication，Indirect Communication。

直接通讯会自动建立两个进程之间的通讯。

Indirect Communication 则会从特定的 mailbox (也称为端口) 中传输信息。

信息传递也可以分为同步和异步的。其中同步意味着需要进行 blocking 的操作。

收发消息时需要建立一个消息队列 (buffer)，当 buffer 的容量为 0  时，发送者必须等待接收者。如果容量是 bounded 的，如果 buffer 满了，sender 也需要等待。如果是 unbounded 则无需等待。



## 线程

> 2023 / 10 / 17

<img src="./操作系统.assets/image-20231017173220397.png" alt="image-20231017173220397" style="zoom:33%;" />

每个线程都代表这一个运行中的 context，有独立的寄存器和栈。不同的线程之间共享代码段、数据、文件。

多线程可以提升软件的响应性与交互性，可以节约、共享资源、提升并发性，更好地适配多核的架构。

### User Thread & Kernel Thread

线程的实现可以只在用户态中实现 (所有 progress，kernel 均视为单线程)。或也可以在内核态下实现。

#### multithreading model

如何实现多线程。

+ many-to-one：多个用户层面的线程最终被映射到了单个内核层面的线程。单个线程的 blocking 会造成所有线程的 blocking。

  <img src="./操作系统.assets/image-20231017174427104.png" alt="image-20231017174427104" style="zoom:33%;" />

+ one-to-one：用户态中创建一个线程，对应地，内核态中也创建一个线程。但若一个进程创建了过多的线程，会影响到系统的运行效率。

  <img src="./操作系统.assets/image-20231017174527588.png" alt="image-20231017174527588" style="zoom:33%;" />

+ many-to-many：内核态中有多个线程，但是不会无限多。

  <img src="./操作系统.assets/image-20231017174702130.png" alt="image-20231017174702130" style="zoom:33%;" />
