## ç¼–è¯‘åŸç†

> 2023 - 2024 æ˜¥å¤

### Introduction

> 2024.02.29

`compiler`: ä¸€ä¸ªå°†ä¸€ç§è¯­è¨€ç¿»è¯‘ä¸ºå¦ä¸€ç§è¯­è¨€çš„ç¨‹åº (è¯­è¨€ä¸è®¡ç®—æœºç›¸å…³)ã€‚

<img src="./ç¼–è¯‘åŸç†.assets/image-20240229105604094.png" alt="image-20240229105604094" style="zoom:25%;" />

#### Typical Workflow of a Compiler

ç¼–è¯‘å™¨çš„å·¥ä½œé˜¶æ®µé€šå¸¸å¦‚ä¸‹ï¼šåˆ†ä¸º**å‰ã€ä¸­ã€å**ä¸‰ç«¯

<img src="./ç¼–è¯‘åŸç†.assets/image-20240229105635243.png" alt="image-20240229105635243" style="zoom:25%;" />

+ **è¯æ³•åˆ†æ** (Lexical Analysis): String $\rightarrow$ token sequence (è®°å·åºåˆ—)ï¼Œåˆ é™¤ä¸å¿…è¦çš„éƒ¨åˆ†ã€‚é€šå¸¸ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼å®šä¹‰ (ä¾‹å¦‚ `rm 2024*`)ï¼Œç”¨äºåŒ¹é…ä¸åŒçš„ tokenã€‚

+ **è¯­æ³•åˆ†æ** (Syntactic Analysis): å°†è®°å·åºåˆ—è§£æä¸ºæŸç§è¯­æ³•ç»“æ„ (å¦‚è¯­æ³•æ ‘)ã€‚

+ **è¯­ä¹‰åˆ†æ** (Semantic Analysis): åˆ†æè¯­æ³•æ ‘èŠ‚ç‚¹çš„å±æ€§ä¿¡æ¯ç­‰ã€‚å¾—åˆ°ç¬¦å·è¡¨ç­‰ã€‚

  <img src="./ç¼–è¯‘åŸç†.assets/image-20240229111638563.png" alt="image-20240229111638563" style="zoom:25%;" />

+ **ä¸­é—´ä»£ç ç”Ÿæˆ** (IR): æºè¯­è¨€ä¸ç›®æ ‡è¯­è¨€çš„æ¡¥æ¢ã€‚(ä¸‰åœ°å€: æ¯ä¸ªè¡¨è¾¾å¼ä¸­è‡³å¤šä¸€ä¸ªæ“ä½œç¬¦ä¸¤ä¸ªæ“ä½œæ•°)

  <img src="./ç¼–è¯‘åŸç†.assets/image-20240229111840556.png" alt="image-20240229111840556" style="zoom:25%;" />
  
+ **åŸºäºä¸­é—´è¡¨ç¤ºçš„ä¼˜åŒ– ** (æœºå™¨æ— å…³ä»£ç ä¼˜åŒ–): å¯¹ä¸­é—´ä»£ç è¿›è¡Œä¼˜åŒ–å’Œå˜æ¢ï¼Œé™ä½æ‰§è¡Œæ—¶é—´ï¼Œå‡å°‘èµ„æºæ¶ˆè€—ã€‚

  <img src="./ç¼–è¯‘åŸç†.assets/image-20240229112209757.png" alt="image-20240229112209757" style="zoom:25%;" />

+ **åç«¯ - ç›®æ ‡ä»£ç ç”Ÿæˆ**: æŠŠä¸­é—´ä»£ç ç¿»è¯‘ä¸ºç›®æ ‡è¯­è¨€ï¼Œæ¶‰åŠåˆ°**æŒ‡ä»¤é€‰æ‹©**ã€**å¯„å­˜å™¨åˆ†é…**ã€**æŒ‡ä»¤è°ƒåº¦**ç­‰ã€‚

  <img src="./ç¼–è¯‘åŸç†.assets/image-20240229112502564.png" alt="image-20240229112502564" style="zoom:25%;" />

#### Tiger ç¼–è¯‘å™¨

<img src="./ç¼–è¯‘åŸç†.assets/image-20240229112935252.png" alt="image-20240229112935252" style="zoom:33%;" />

+ **AST** (æŠ½è±¡è¯­æ³•æ ‘): ç»è¿‡è¯­æ³•åˆ†æ + "Parsing Actions" ç”Ÿæˆã€‚
+ **IR Tree** (æ ‘å‹ä¸­é—´è¡¨ç¤º): è¯­ä¹‰åˆ†æä¹‹åæŒ‰ç…§ä¸€å®šè§„åˆ™ç”Ÿæˆã€‚è¿›è¡Œäº†å½’ä¸€åŒ– (Canonicalized) çš„æ“ä½œã€‚
+ **Control Flow Analysis** (æ§åˆ¶æµåˆ†æ): åˆ¤æ–­åˆ†æ”¯è¯­å¥çš„æ‰§è¡Œè·¯å¾„ (å¯ä»¥å»é™¤ä¸å¯è¾¾çš„è·¯å¾„)ã€‚
  + **CFG** (Control Flow Graph) (æ§åˆ¶æµå›¾): æ–¹ä¾¿è¿›è¡Œæ•°æ®æµåˆ†æâ€“å¦‚æ´»è·ƒå˜é‡åˆ†æ (Liveness Analysis)ã€‚
+ **Interference Graph** (å†²çªå›¾): ä»æ´»è·ƒå˜é‡åˆ†æçš„ç»“æœæ„é€ ï¼Œç”¨äºæŒ‡å¯¼å¯„å­˜å™¨åˆ†é…ã€‚



### Lexical Analysis è¯æ³•åˆ†æ

> 2024.03.07

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307113231210.png" alt="image-20240307113231210" style="zoom:16%;" />

#### Lexical Token

`å®šä¹‰`ï¼šä¸€ä¸ªå­—æ¯åºåˆ—ï¼Œæ–‡æ³•ä¸­çš„åŸºæœ¬å•å…ƒã€‚

å¸¸è§çš„ **token** æœ‰ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307101433721.png" alt="image-20240307101433721" style="zoom:27%;" />

*å¤šæ•°è¯­è¨€ä¸­ä¿ç•™è¯ä¸ä½œä¸º identifiersã€‚*

å¸¸è§çš„ **non-token** æœ‰ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307101557052.png" alt="image-20240307101557052" style="zoom:27%;" />

è¯æ³•åˆ†æçš„ç¤ºä¾‹å¦‚ä¸‹ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307101803168.png" alt="image-20240307101803168" style="zoom:18%;" />

#### Regular Expression

*ä½¿ç”¨**æ­£åˆ™è¡¨è¾¾å¼**æ¥æè¿° token è§„åˆ™ï¼Œå†ä½¿ç”¨ **DFA** å®ç°ä¸Šè¿°çš„æ­£åˆ™è¡¨è¾¾å¼ã€‚*

*è¯æ³•åˆ†æé˜¶æ®µä¸ç”¨å…³å¿ƒ string çš„å«ä¹‰ï¼Œåªéœ€è¦å…³å¿ƒå­—ç¬¦ä¸²æ˜¯å¦åœ¨è¯­è¨€ä¸­ã€‚*

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307103325675.png" alt="image-20240307103325675" style="zoom:25%;" />

!!!note
	å…¶ä¸­ a | $\epsilon$ ä¸ a | ç­‰ä»·ã€‚

!!!note
	**æ›´å¤šçš„ç®€å†™ï¼š**<br>
	<img src="./ç¼–è¯‘åŸç†.assets/image-20240307103937977.png" alt="image-20240307103937977" style="zoom:18%;" /><br>
	ç®€å†™ä¸ä¼šè®©æ­£åˆ™è¡¨è¾¾å¼çš„è¡¨è¾¾èƒ½åŠ›å¢åŠ ã€‚<br>

!!!note
	<img src="./ç¼–è¯‘åŸç†.assets/image-20240307104153951.png" alt="image-20240307104153951" style="zoom:25%;" /><br>
	ç¬¬äº”è¡Œè¡¨ç¤ºçš„æ˜¯**æ³¨é‡Š**æˆ–**ç©ºæ ¼ã€æ¢è¡Œ**ç­‰ã€‚<br>
	!!!warning
		ä¸Šè¿°çš„ä¾‹å­ä¸­å­˜åœ¨æ­§ä¹‰ï¼Œä¾‹å¦‚ `if8` å¯ä»¥è§£é‡Šä¸º ID ä¹Ÿå¯ä»¥è§£é‡Šä¸º if + 8ã€‚<br>
		ç°ä»£çš„ç¼–è¯‘å™¨ä¼šå¼•å…¥æœ€é•¿åŒ¹é…æœºåˆ¶ä¸”æŒ‰ç…§è§„åˆ™çš„ä¼˜å…ˆçº§é€æ¡åŒ¹é… (if8 è§£é‡Šä¸º ID)ã€‚

#### Finite Automata

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307110214618.png" alt="image-20240307110214618" style="zoom:30%;" />

`ç¡®å®šæ€§çŠ¶æ€æœº`ï¼š**no two edges leaving from the same state** are labeled with the same symbol. 

å°†ä¸Šè¿°çš„å…­ä¸ª DFA æ‹¼æ¥æˆä¸€ä¸ª DFAï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307110738639.png" alt="image-20240307110738639" style="zoom: 25%;" />

è®¡ç®—æœºä¸­ DFA çš„å®é™…ä¸Šé€šè¿‡è¡¨æ ¼çš„æ–¹å¼ (**transition matrix**) å®ç°çš„ã€‚

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307111430774.png" alt="image-20240307111430774" style="zoom:22%;" />

+ æ¯ä¸€è¡Œè¡¨ç¤ºä¸€ä¸ªçŠ¶æ€ï¼Œæ¯ä¸€åˆ—è¡¨ç¤ºè¯»å…¥çš„ symbolï¼Œå­˜å‚¨çš„å€¼è¡¨ç¤ºè¯»å…¥åè·³è½¬åˆ°çš„çŠ¶æ€ã€‚
+ 0 è¡¨ç¤ºé”™è¯¯çŠ¶æ€ã€‚

é¢å¤–éœ€è¦ä¸€ä¸ªçŸ©é˜µå­˜å‚¨æ¯ä¸€ä¸ªçŠ¶æ€æ˜¯å¦ä¸ºç»ˆæ€ (**"finality" array**)ï¼Œä»¥åŠå…¶å¯¹åº”çš„è¾“å‡ºæ ‡ç­¾æ˜¯ä»€ä¹ˆã€‚

+ ä¸ºå®ç° Longest matchingï¼Œæ¯æ¬¡é‡åˆ°å¯ä»¥ç»ˆæ­¢çš„èŠ‚ç‚¹æ—¶ï¼Œå…ˆè®°å½•å½“å‰çš„åˆ†æç»“æœï¼Œç»§ç»­å‘åæ‰«æï¼Œç›´åˆ°æ— æ³•æ‰«æä¸ºæ­¢ã€‚
  + éœ€è¦ `Last-Final`ï¼Œ`Input-Position-at-Last-Final` ä¸¤ä¸ªå˜é‡è¿›è¡Œè®°å½•ã€‚
  + <img src="./ç¼–è¯‘åŸç†.assets/image-20240307112415882.png" alt="image-20240307112415882" style="zoom:32%;" />
  + <img src="./ç¼–è¯‘åŸç†.assets/image-20240307112910258.png" alt="image-20240307112910258" style="zoom:33%;" />

#### Nondeterministic Finite Automata

**Thompson's Construction**

> å°†æ­£åˆ™è¡¨è¾¾å¼è½¬åŒ–ä¸º NFA

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307114418944.png" alt="image-20240307114418944" style="zoom:32%;" />

|                         Regular Exp                          |                             NFA                              |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="./ç¼–è¯‘åŸç†.assets/image-20240307115219803.png" alt="image-20240307115219803" style="zoom:33%;" /> | <img src="./ç¼–è¯‘åŸç†.assets/image-20240307115235538.png" alt="image-20240307115235538" style="zoom:33%;" /> |

**Subset Construction**

> å°† NFA è½¬åŒ–ä¸º DFA

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307120207165.png" alt="image-20240307120207165" style="zoom:20%;" />

+ **edge(s, c)**ï¼š1.the set of all NFA states reachable by following a single edge with label *c* from state *s*.
+ **closure(S)**ï¼šthe set of states that can be reached from a state in *S* without consuming any of the input, that is, by going only through âˆŠ-edges. 

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307121141938.png" alt="image-20240307121141938" style="zoom:30%;" />

ç®—æ³•æ€æƒ³ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307121201189.png" alt="image-20240307121201189" style="zoom:33%;" />

ç®—æ³•å®ç°ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307121246802.png" alt="image-20240307121246802" style="zoom:33%;" />

ç®—æ³•ä¾‹å­ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307122035132.png" alt="image-20240307122035132" style="zoom:18%;" />

|                             NFA                              |                             DFA                              |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="./ç¼–è¯‘åŸç†.assets/image-20240307115235538.png" alt="image-20240307115235538" style="zoom:30%;" /> | <img src="./ç¼–è¯‘åŸç†.assets/image-20240307122243841.png" alt="image-20240307122243841" style="zoom:20%;" /> |

ä¸Šè¿°å³å›¾çš„éƒ¨åˆ†ç­‰ä»·çŠ¶æ€å¯ä»¥åˆå¹¶ï¼Œä»¥ç¼©å° DFAã€‚ä½†æœ‰éƒ¨åˆ†çš„ç­‰ä»·çŠ¶æ€æ— æ³•æ¶ˆé™¤ã€‚

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307122759170.png" alt="image-20240307122759170" style="zoom: 23%;" />

ä¸Šè¿°çš„ç®—æ³•æ€»ä½“æ€æƒ³ä¸ºæ‰¾åˆ°éç­‰ä»·çš„çŠ¶æ€ï¼Œä¸¾ä¾‹å¦‚ä¸‹ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240307144035741.png" alt="image-20240307144035741" style="zoom:26%;" />

#### Lex: A Lexical Analyzer Generator

Lex æ˜¯ä¸€ä¸ªç¨‹åºï¼Œ

+ è¾“å…¥ï¼ša text file containing regular expressions, together with the actions to be taken when each expression is matched.
  + <img src="./ç¼–è¯‘åŸç†.assets/image-20240314100840000.png" alt="image-20240314100840000" style="zoom:25%;" />
+ è¾“å‡ºï¼šContains C source code defining a procedure *yylex* that is *a* table-driven implementation of a DFA corresponding to the regular expressions of the input file, and that operates like a *getToken* procedure.



### Syntax analysis è¯­æ³•åˆ†æ

> 2024.03.14

<img src="./ç¼–è¯‘åŸç†.assets/image-20240314101147943.png" alt="image-20240314101147943" style="zoom:33%;" />

#### CFG ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•

æ­£åˆ™è¡¨è¾¾å¼çš„æ— æ³•è¡¨è¾¾æ‹¬å·åŒ¹é…ç­‰ Recursive Structure è§„åˆ™ã€‚

CFG åœ¨è¿›è¡Œæ›¿æ¢æ—¶ä¸éœ€è¦å…³å¿ƒ non-terminal symbol çš„å·¦å³ (ä¸Šä¸‹æ–‡) å¦‚ä½•ï¼Œæ ¹æ®è§„åˆ™è¿›è¡Œæ›¿æ¢å³å¯ã€‚

ä¸€ä¸ªä¸å«åˆ†æ”¯è¯­å¥çš„ç¨‹åºçš„ CFG å¯ä»¥è¡¨è¾¾å¦‚ä¸‹ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240314103324107.png" alt="image-20240314103324107" style="zoom:33%;" />

å…¶ä¸­ S è¡¨ç¤ºè¯­å¥ï¼Œå¯ä»¥ä½¿ç”¨åˆ†å·é¡ºåºè¿æ¥ã€‚E ä¸ºæ•°å­—æˆ–å˜é‡ã€‚

åœ¨åˆ¤æ–­ç¨‹åºæ˜¯å¦æ­£ç¡®æ—¶ï¼Œä¸»è¦æ€è·¯ä¸ºåˆ¤æ–­ç¨‹åºæ˜¯å¦æœ‰è¯­æ³•é”™è¯¯ã€‚

<img src="./ç¼–è¯‘åŸç†.assets/image-20240314104017211.png" alt="image-20240314104017211" style="zoom:33%;" />

ä¸Šè¿°æ¨å¯¼éµå¾ªäº†æœ€å·¦æ¨å¯¼ left-most derivationï¼Œå¯ä»¥æ ¹æ®æ¬¡ç”Ÿæˆ parsing treeã€‚æŸäº›æƒ…å†µä¸‹æœ€å·¦å’Œæœ€å³æ¨å¯¼ç­‰ä»· (å½“æ–‡æ³•æ²¡æœ‰æ­§ä¹‰æ—¶)ã€‚

<img src="./ç¼–è¯‘åŸç†.assets/image-20240314104507327.png" alt="image-20240314104507327" style="zoom:33%;" />

ä¸€é¢— parsing tree å¯èƒ½å¯¹åº”å¤šä¸ªæ¨å¯¼å…³ç³»ã€‚

**æ­§ä¹‰**

<img src="./ç¼–è¯‘åŸç†.assets/image-20240314105036328.png" alt="image-20240314105036328" style="zoom:33%;" />

éœ€è¦å¯¹ç”Ÿæˆçš„è§„åˆ™è¿›è¡Œæ›´æ”¹ä»¥æ¶ˆé™¤æ­§ä¹‰ã€‚è§„å®šä¹˜æ³•ä¼˜å…ˆçº§é«˜äºåŠ æ³•ï¼Œå¹¶ç»Ÿä¸€è¿›è¡Œå·¦ç»“åˆã€‚

<img src="./ç¼–è¯‘åŸç†.assets/image-20240314110711697.png" alt="image-20240314110711697" style="zoom:33%;" />

ä¸ºè¯†åˆ«æ˜¯å¦å·²ç»è¯»åˆ°æ–‡ä»¶çš„æœ«å°¾ï¼Œå¼•å…¥ \$ (EOF)ã€‚åœ¨è§„åˆ™ä¸­åŠ å…¥ $S\rightarrow E \$ $ã€‚

#### Top-Down Parsing

**Recursive Descent Parsing**: parses **LL(1)** grammars ï¼š **L**eft-to-right parse; **L**eftmost-derivation; **1**symbol lookahead.

æ ¹æ®è¯»å–åˆ°çš„ tokenï¼Œä»å·¦åˆ°å³è¯»å–ï¼Œå°è¯•å¯»æ‰¾è§„åˆ™è¿›è¡ŒåŒ¹é…è¿›è¡Œ parsing tree çš„æ„å»ºã€‚

<img src="./ç¼–è¯‘åŸç†.assets/image-20240314111915045.png" alt="image-20240314111915045" style="zoom:33%;" />

~~~c++
enum token {IF, THEN, ELSE, BEGIN, END, PRINT, SEMI, NUM, EQ};
extern enum token getToken(void);
enum token tok; 
void advance() {tok=getToken();} 
void eat(enum token t) {if (tok==t) advance(); else error();}
void S(void) {
    switch(tok) { 
    case IF: eat(IF); E(); eat(THEN); S(); eat(ELSE); S(); break; 
    case BEGIN: eat(BEGIN); S(); L(); break; 
    case PRINT: eat(PRINT); E(); break; 
    default: error(); }}
void L(void) {
    switch(tok) {
    case END: eat(END); break;
    case SEMI: eat(SEMI); S(); L(); break;
    default: error(); }}
void E(void) { eat(NUM); eat(EQ); eat(NUM); }
~~~

ä¸Šè¿°çš„å®ç°ä¸»è¦ä¾é æ›¿æ¢åçš„ç¬¬ä¸€ä¸ª symbol è¿›è¡Œè§„åˆ™çš„é€‰æ‹©ï¼Œä½†å¹¶ä¸é€‚ç”¨ä¸æ‰€æœ‰çš„è¯­æ³•ã€‚

**Predictive Parsing**

å¯¹äºæ— æ³•é€šè¿‡ç¬¬ä¸€ä¸ª symbol è¿›è¡Œåˆ¤æ–­ (ä¾‹å¦‚éƒ½æ˜¯ non-terminal)ï¼ŒåŸºäºä¸€å®šçš„è§„åˆ™è¿›è¡Œè®¡ç®—é¦–å…ˆæ´¾ç”Ÿå‡ºçš„ terminal symbolï¼Œå†è¿›è¡Œåˆ¤æ–­ã€‚

å¯¹äºä¾‹å¦‚ $Z\rightarrow XY$ çš„è§„åˆ™ï¼Œé¦–å…ˆéœ€è¦è€ƒè™‘çš„æ˜¯ X åœ¨æ´¾ç”Ÿä¹‹åä¼šäº§ç”Ÿçš„ç¬¬ä¸€ä¸ª terminal ç¬¦å· (First)ã€‚ä½†éœ€è¦è€ƒè™‘åˆ° X å¯èƒ½æ´¾ç”Ÿå‡ºç©ºä¸² $\varepsilon$ (Nullable)ï¼Œæ‰€ä»¥éœ€è¦è€ƒè™‘ Y å¯èƒ½æ´¾ç”Ÿå‡ºçš„ç¬¬ä¸€ä¸ª terminalã€‚ä½† Y è‹¥ä¹Ÿå¯èƒ½æ´¾ç”Ÿå‡º $\varepsilon$, åˆ™éœ€è¦è€ƒè™‘ç´§è·Ÿåœ¨ Y ä¹‹åçš„ terminal (Follow)ã€‚

$\gamma\rightarrow^* t\beta$ï¼Œå…¶ä¸­ t ä¸º terminal symbolã€‚$\gamma$ å’Œ $\beta$ è¡¨ç¤ºä»»æ„çš„å­—ç¬¦ä¸²ï¼Œ$t\in First(\gamma)$ã€‚

$X \rightarrow^* \alpha Xt \beta$ï¼Œ$\alpha$ å’Œ $\beta$ è¡¨ç¤ºä»»æ„çš„å­—ç¬¦ä¸²ï¼Œ$t\in Follow(X)$ã€‚

è®¡ç®— Nullable ç®—æ³•ï¼š

~~~c
for each symbol X:
	Nullable(X) = False
repeat
	for each production X -> Y1 Y2 â€¦ Yk:
		if Nullable(Yi) = True for all 1 <= i <= k:
			Nullable(X) = True
until Nullable did not change in this iteration
~~~

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ¯ä¸€è½®éƒ½éœ€è¦éå†æ‰€æœ‰çš„è§„åˆ™ï¼Œæ¯ä¸€è½®å¾ªç¯ç»“æŸéƒ½éœ€è¦å’Œå‰ä¸€æ¬¡çš„ç»“æœè¿›è¡Œæ¯”è¾ƒï¼Œç›´åˆ°æ²¡æœ‰å˜åŒ–åç»“æŸå¾ªç¯ã€‚

<img src="./ç¼–è¯‘åŸç†.assets/image-20240314190711432.png" alt="image-20240314190711432" style="zoom:30%;" />

First å’Œ Follow çš„ç®—æ³•å¦‚ä¸‹ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240314190942745.png" alt="image-20240314190942745" style="zoom:33%;" />

ä¸¾ä¾‹å¦‚ä¸‹ï¼š

|                           First-1                            |                           First-2                            |                           First-3                            |                           First-4                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="./ç¼–è¯‘åŸç†.assets/image-20240314191145302.png" alt="image-20240314191145302" style="zoom:25%;" /> | <img src="./ç¼–è¯‘åŸç†.assets/image-20240314191203858.png" alt="image-20240314191203858" style="zoom:25%;" /> | <img src="./ç¼–è¯‘åŸç†.assets/image-20240314191230625.png" alt="image-20240314191230625" style="zoom:25%;" /> | <img src="./ç¼–è¯‘åŸç†.assets/image-20240314191249938.png" alt="image-20240314191249938" style="zoom:25%;" /> |

|                           Follow-1                           |                           Follow-2                           |                           Follow-3                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="./ç¼–è¯‘åŸç†.assets/image-20240314191510728.png" alt="image-20240314191510728" style="zoom:33%;" /> | <img src="./ç¼–è¯‘åŸç†.assets/image-20240314191527783.png" alt="image-20240314191527783" style="zoom:33%;" /> | <img src="./ç¼–è¯‘åŸç†.assets/image-20240314191552450.png" alt="image-20240314191552450" style="zoom:33%;" /> |

éœ€è¦é¢å¤–æ³¨æ„çš„æ˜¯ $X\rightarrow Y$ è§„åˆ™ä¼šä½¿ Follow(Y) å’Œ Follow(X) å‡ºç°é‡åˆã€‚æœ€ç»ˆå¯ä»¥å¾—åˆ°å¦‚ä¸‹è¡¨æ ¼ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240314192039713.png" alt="image-20240314192039713" style="zoom:33%;" />

éœ€è¦å°†ä¸Šè¿°çš„è¡¨æ ¼è½¬åŒ–ä¸ºä¸€ä¸‹çš„è¡¨æ ¼ï¼Œä»¥æŒ‡æ˜ä½¿ç”¨é‚£æ¡è§„åˆ™è¿›è¡Œ parsing tree çš„æ„å»ºï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240314192213690.png" alt="image-20240314192213690" style="zoom:30%;" />

æ„å»ºçš„ç®—æ³•å¦‚ä¸‹ï¼š

+ if T $\in$ First($\gamma$) then enter $X\rightarrow \gamma$ in row X, col T.
+ if $\gamma$ is Nullable and T $\in$ Follow(X) then enter $X\rightarrow \gamma$ in row X, col T.

ä¸Šè¿°çš„è¡¨æ ¼æŒ‡çš„æ˜¯ï¼Œåœ¨è‡ªé¡¶å‘ä¸‹æ´¾ç”Ÿ non-terminal æ—¶ï¼Œè¯»åˆ°è¯æ³•åˆ†æå¾—åˆ°çš„åºåˆ—ä¸­çš„æŸä¸ª symbol æ—¶éœ€è¦é€‰æ‹©çš„è§„åˆ™ã€‚è‹¥æ˜¯æŸ¥è¡¨å¾—åˆ°äº†ç©ºæ ¼ï¼Œåˆ™è¡¨ç¤ºå‡ºç°äº†è¯­æ³•é”™è¯¯ã€‚

è¿˜éœ€è¦æ³¨æ„ä¸Šè¿°çš„è¡¨æ ¼è¿˜å­˜åœ¨å¤šæ¡è§„åˆ™ä¸€ä¸ªç©ºæ ¼çš„æƒ…å†µï¼Œè¿™å¯èƒ½ç”±ä¸¤ç§æƒ…å†µå¯¼è‡´ï¼š

+ Left-Recursiveï¼š$A\rightarrow A\alpha,\,A\rightarrow\beta$.
  + ä¿®æ”¹åï¼š$A\rightarrow\beta A',\,A'\rightarrow\alpha A', A'\rightarrow \varepsilon$.
+ Left-Left Factoringï¼šä¿®æ”¹å¦‚ä¸‹ï¼š
  + <img src="./ç¼–è¯‘åŸç†.assets/image-20240314194155167.png" alt="image-20240314194155167" style="zoom:33%;" />

ä¸¾ä¾‹å¦‚ä¸‹ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240314194720103.png" alt="image-20240314194720103" style="zoom:30%;" />

**é”™è¯¯æ¢å¤**

ä¸€èˆ¬æ¥è¯´ï¼Œåœ¨é‡åˆ°é”™è¯¯åï¼Œéœ€è¦ä»é”™è¯¯ä¸­æ¢å¤è¿‡æ¥ç»§ç»­è¿›è¡Œè¯­æ³•åˆ†æï¼Œä»¥åˆ†æå¾—åˆ°æ›´å¤šçš„æ½œåœ¨çš„è¯­æ³•é”™è¯¯ã€‚

å¸¸è§çš„åšæ³•å¦‚ä¸‹ï¼š

~~~c++
int Tprime_follow[] = {PLUS, RPAREN, EOF}; 
void Tprime() { 
	switch (tok) { 
		case PLUS: break; 
		case TIMES: eat(TIMES); F(); Tprime(); break; 
		case RPAREN: break; 
		case EOF: break; 
		default: print("expected +, *, right-paren, or end-of-file"); 
 		skipto(Tprime_follow); 
 	}
}
~~~

**LL(k)**

k è¡¨ç¤ºåœ¨é€‰æ‹©æ´¾ç”Ÿè§„åˆ™æ—¶éœ€è¦æ ¹æ®å‡ ä¸ª input æ‰èƒ½åˆ¤å®šã€‚LL(1) å°±è¡¨ç¤ºä¸€ä¸ª 1 ä¸ª token å°±èƒ½æ— æ­§ä¹‰çš„è¿›è¡Œè§„åˆ™é€‰æ‹©ã€‚

==every LL(k) grammar is an LL(k+n) grammar, for any n.==

æ‰€ä»¥åœ¨ä¾‹å¦‚åœ¨è¯æ˜ä¸€ä¸ª grammar æ˜¯ LL(3) æ—¶ï¼Œå¯ä»¥å…ˆå°è¯•è¯æ˜å…¶ä¸º LL(1).

#### LR(k) parsing

ç›¸æ¯” LL(k)ï¼Œä¸æ€¥äºåšåŒ¹é…ï¼Œç›´åˆ° input tokens corresponding to the **entire right-hand side** of the production. 

+ ç‰¹å¾ï¼š**L**eft-to-right parseã€**R**ightmost derivationã€**k**-token lookaheadã€‚
+ æ˜¯ä¸€ç§ `bottom-up Parsing`ã€‚
+ ä¸æ–­å°†äº§ç”Ÿå¼çš„å³éƒ¨æ›¿æ¢ä¸ºå·¦éƒ¨ã€‚

ä¸¾ä¾‹å¦‚ä¸‹ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240321110518813.png" alt="image-20240321110518813" style="zoom:33%;" />

ä»ä»¥ä¸Šçš„è¿‡ç¨‹å¯ä»¥çœ‹å‡ºä»¥ä¸Šçš„è¿‡ç¨‹è‡ªä¸‹å¾€ä¸Šçœ‹å®é™…ä¸Šä¸ºæœ€å³å±•å¼€ã€‚

<img src="./ç¼–è¯‘åŸç†.assets/image-20240321111511601.png" alt="image-20240321111511601" style="zoom:33%;" />

åˆ†ä¸º shift å’Œ reduce ä¸¤ä¸ªè¿‡ç¨‹ã€‚

+ **shift**: push next input onto top of stack

+ **reduce R**:  
  + top of stack should match RHS of rule R (e.g., X -> A B C)
  + pop the RHS from the top of stack (e.g., pop C B A)
  + push the LHS onto the stack (e.g., push X)

+ **error**

+ **accept:** shift $ and can reduce what remains on stack 

**LR(0) Parsing**

åªéœ€è¦åœ¨ state stack ä¸­çœ‹å°±å¯ä»¥åˆ¤æ–­ã€‚

å¯ä»¥ä½¿ç”¨ DFA æ¥ç¡®å®šæ˜¯å¦ reduceã€‚

<img src="./ç¼–è¯‘åŸç†.assets/image-20240321112902898.png" alt="image-20240321112902898" style="zoom:33%;" />

+ **.** : the current position of the parser

+ start with Sâ€™ -> . S \$: stack should be empty and the input is expected to be a complete S-sentence followed by \$
+ A -> ğ›¼ . Î²: LR(0) item
+ means the parser has processed ğ›¼ and expects to see Î² next.

æ¥ä¸‹æ¥å°† NFA è½¬åŒ–ä¸º DFAã€‚

<img src="./ç¼–è¯‘åŸç†.assets/image-20240321113113370.png" alt="image-20240321113113370" style="zoom:33%;" />

å…·ä½“ç®—æ³•å¦‚ä¸‹ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240321114549316.png" alt="image-20240321114549316" style="zoom:22%;" />

åº”ç”¨ä¸Šè¿°çš„ç®—æ³•ï¼Œå¯¹äº grammarï¼š

**Sâ€™** **->** **S$**   **S** **->** **(** **L** **)**   **S** **->** **x**   **L** **->** **S**   **L** **->** **L** **,** **S**

<img src="./ç¼–è¯‘åŸç†.assets/image-20240321115755179.png" alt="image-20240321115755179" style="zoom:33%;" />

| **Stack**  **(states)**      | **Stack**  **(symbols)** | **Input**                 | **Action**                                            |
| ---------------------------- | ------------------------ | ------------------------- | ----------------------------------------------------- |
| **1**                        |                          | **(** **x**  **)**  **$** | **shift**  **3**                                      |
| **1,** **3**                 | **(**                    | **x** **)**  **$**        | **shift**  **2**                                      |
| **1,** **3,**  **2**         | **(** **x**              | **)** **$**               | **reduce**  **2**  **S**  **->**  **x**               |
| **1,** **3**                 | **(** **S**              | **)** **$**               | **goto**  **7**                                       |
| **1,** **3,**  **7**         | **(** **S**              | **)** **$**               | **reduce**  **3**  **L**  **->**  **S**               |
| **1,** **3**                 | **(** **L**              | **)** **$**               | **goto**  **5**                                       |
| **1,** **3,**  **5**         | **(** **L**              | **)** **$**               | **shift**  **6**                                      |
| **1,** **3,**  **5,**  **6** | **(** **L**  **)**       | **$**                     | **reduce**  **1**  **S**  **->**  **(**  **L**  **)** |
| **1**                        | **S**                    | **$**                     | **goto**  **4**                                       |
| **1,** **4**                 | **S**                    | **$**                     | **accept**                                            |

å¯ä»¥å¾—åˆ°ä»¥ä¸‹çš„ parsing tableï¼š

|       | **(**  | **)**  | **x**  | **,**  | **$**  | **S**  | **L**  |
| ----- | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| **1** | **s3** |        | **s2** |        |        | **g4** |        |
| **2** | **r2** | **r2** | **r2** | **r2** | **r2** |        |        |
| **3** | **s3** |        | **s2** |        |        | **g7** | **g5** |
| **4** |        |        |        |        | **a**  |        |        |
| **5** |        | **s6** |        | **s8** |        |        |        |
| **6** | **r1** | **r1** | **r1** | **r1** | **r1** |        |        |
| **7** | **r3** | **r3** | **r3** | **r3** | **r3** |        |        |
| **8** | **s3** |        | **s2** |        |        | **g9** |        |
| **9** | **r4** | **r4** | **r4** | **r4** | **r4** |        |        |

å…·ä½“çš„æ“ä½œè§„åˆ™å¦‚ä¸‹ï¼š

+ **Shift**: For edge labeled with terminal t and from state i to state n: 
  + T[i, t] = **sn** (shift n)

+ **Goto**: For edge labeled with non-terminal X and from state i to state n: 
  + T[i, X] = **gn** (goto n)

+ **Reduce:** For item in a state **i** with dot at the end (e.g., *X* *->* *A* *â€¦* *C* *.*):

  + T[i, each terminal] = **rk** (reduce k)

  + k is the **index** **of** **this** **production**

+ **Accept:** For each state i containing 

  + Sâ€™ -> S . $:

  + T[i, $] = **accept**

**Simple LR Parsing**

å¯èƒ½ä¼šå­˜åœ¨ shift-reduce å†²çªï¼Œå³æ— æ³•åˆ¤æ–­æ˜¯å¦éœ€è¦ reduceã€‚

å¼•å…¥ SLR æ–¹æ³•ï¼ŒåŸºæœ¬æ€æƒ³æ˜¯è®¡ç®— Follow é›†åˆï¼š

~~~c
R â† {} 
for each state I in T 
     for each item A â†’ Î±. in I 
           for each token X in FOLLOW(A) 
              R â† R âˆª {(I, X, A â†’ Î±)} 
I: the row
X: the column
A â†’ Î±: the production
~~~

**LR(1) Parsing**

éœ€è¦å¾€åçœ‹ä¸€ä¸ª symbol ä»¥è¾…åŠ©åŠ¨ä½œé€‰æ‹©ã€‚

+ ($A \rightarrow \alpha.\beta$, x), x è¡¨ç¤º $\beta$ å¤„ç†å®Œä¹‹åï¼Œå°†çœ‹åˆ°çš„ symbolã€‚

~~~c
Closure(I) = 
    repeat 
        for any item (A â†’ Î±.XÎ², z) in I 
           for any production X â†’ Î³ 
               for any w âˆˆ FIRST(Î²z) 
                  I â† I âˆª {(X â†’ .Î³, w)} 
    until I does not change 
	return I

Goto(I, X) = 
    J â† {} 
    for any item (A â†’ Î±.XÎ², z) in I    
        add (A â†’ Î±X. Î², z) to J 
    return Closure(J)
        
// reduce
R â† { } 
for each state I in T     
    for each item (A â†’ Î±., z) in I 
         R â† R âˆª{(I, z, A â†’ Î±)} 
~~~



### Abstract Syntax æŠ½è±¡è¯­æ³•

> 2024.04.11

å¦‚ä½•æ„å»ºæŠ½è±¡è¯­æ³•æ ‘ ASTï¼Œå¦‚ä½•å°†è¯­ä¹‰ä¿¡æ¯å¤„ç†åŠ å…¥åˆ°åŠ å…¥åˆ°è¯­æ³•åˆ†æä¸­å»ã€‚

!!!note
	åœ¨ recursive-descent parser ä¸­ï¼Œè¯­ä¹‰åŠ¨ä½œæœ‰ values (å¦‚ç®—å¼ç»“æœ)ï¼Œæˆ–è€… side effects (å¦‚èµ‹å€¼è¯­å¥ã€å‡½æ•°è°ƒç”¨)ï¼Œéƒ½éœ€è¦è®°å½•ã€‚

<img src="./ç¼–è¯‘åŸç†.assets/image-20240411103535540.png" alt="image-20240411103535540" style="zoom:25%;" />

ä¸€äº›æƒ…å†µä¸‹éœ€è¦è¿›è¡Œè¯­ä¹‰å€¼å¾—ä¼ é€’ã€‚ä¾‹å¦‚ï¼šT â†’ F Tâ€²ï¼›Tâ€² â†’ *F Tâ€²ï¼›Tâ€² â†’ / F Tâ€²ï¼Œéœ€è¦å°† F çš„å€¼å‘ä¸‹ä¼ é€’ã€‚

!!!note
	Yacc ä¸­çš„éƒ¨åˆ†è¯­æ³•ï¼š<br>
 	{ â€¦ }: semantic actions<br>
 	\$i: the semantic values of the i_th RHS symbol<br>
 	\$\$: the semantic value of the LHS nonterminal symbol<br>
 	%union: difference possible types for semantic values to carry<br>
 	<variant\>: declares the type of each terminal or nonterminal<br>

Yacc ä»£ç ä¸¾ä¾‹å¦‚ä¸‹ï¼š

~~~c
%{ â€¦ %}
%union {int num; string id;}
%token <num> INT
%token <id> ID
%type <num> exp
...
%left UMINUS
%%

exp: INT {$$ = $1;}
   | exp PLUS exp {$$ = $1 + $3;}
   | exp MINUS exp {$$ = $1 - $3;}
   | exp TIMES exp {$$ = $1 * $3;}
   | MINUS exp %prec UMINUS {$$ = -$2;}
~~~

#### Abstract Syntax Tree

<img src="./ç¼–è¯‘åŸç†.assets/image-20240411110554872.png" alt="image-20240411110554872" style="zoom:33%;" />

ç›¸æ¯”å…·ä½“è¯­æ³•ï¼ŒæŠ½è±¡è¯­æ³•ç•¥å»äº†ä¸€äº›å†—ä½™çš„ä¿¡æ¯ä¾¿äºè®¡ç®—æœºè¿›è¡Œå¤„ç†ã€‚

ä¸ºæ–¹ä¾¿é”™è¯¯æ¢å¤ï¼Œå¯ä»¥è®°å½•ä¸‹æ¯ä¸€ä¸ª token çš„ä½ç½®ä¿¡æ¯ã€‚



### Semantic Analysis è¯­ä¹‰åˆ†æ

> 2024.04.11

å¦‚ä½•å°†å£°æ˜ä¸ä½¿ç”¨è”ç³»åˆ°ä¸€èµ·ï¼Œæ£€æŸ¥è¡¨è¾¾å¼æ˜¯å¦æ­£ç¡®ã€‚

#### Symbol Tables ç¬¦å·è¡¨

+ `environment`ï¼šå˜é‡ä¸å…¶ç±»å‹çš„å®šä¹‰ç»‘å®šã€‚
  + $\sigma_0=\{g\rightarrow string, a\rightarrow int\}$
  + $\sigma_1=\sigma_0+\{b\rightarrow string, a\rightarrow int\}$
  + ä¸¤ä¸ªç¬¦å·è¡¨å­˜åœ¨ä¸€ä¸ªâ€œå†²çªâ€ï¼Œéœ€è¦æ³¨æ„åˆ°çš„æ˜¯å±€éƒ¨ç±»å‹å¯ä»¥è¦†ç›–å…¨å±€çš„ç±»å‹ã€‚åŠ å·å³ä¾§çš„ä¼˜å…ˆçº§æ›´é«˜ã€‚
  + ä¸€ä¸ªå±€éƒ¨è¯­å¥å—ç»“æŸæ—¶ï¼Œå¯ä»¥æŠ›å¼ƒå±€éƒ¨çš„ç¬¦å·è¡¨ï¼š
    + discard $\sigma_1$, go back to $\sigma_0$

å®ç°ç¬¦å·è¡¨æœ‰ä¸¤ç§æ–¹å¼ï¼š

+ Functional Styleï¼šä¿ç•™æ¯ä¸€çº§çš„ç¬¦å·è¡¨ã€‚
+ Imperative Styleï¼šåªæ˜¯åœ¨ä¸€ä¸ªç¬¦å·è¡¨ä¸Šè¿›è¡Œä¿®æ”¹ã€‚

å¯¹äºä¸€äº›é¢å‘å¯¹è±¡çš„è¯­è¨€ï¼Œéœ€è¦æœ‰å¤šä¸ªç¬¦å·è¡¨ï¼Œä¾‹å¦‚ï¼š

~~~java
class E { Â Â 
    static int a = 5; Â Â 
}
~~~

å¯ä»¥å†™ä½œï¼š$\sigma_0 = \{a\rightarrow int\},\,\sigma_1=\{E\rightarrow \sigma_0\}$

ç¬¦å·è¡¨åœ¨å…·ä½“å®ç°æ—¶ç»å¸¸ä½¿ç”¨å“ˆå¸Œè¡¨ä»¥å®ç°å¿«é€Ÿçš„æ’å…¥ä¸åˆ é™¤ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240411113624509.png" alt="image-20240411113624509" style="zoom:33%;" />

å¯¹äºå‡½æ•°å¼çš„ç¬¦å·è¡¨ï¼Œå¯ä»¥ä½¿ç”¨å¦‚ä¸‹çš„æŒ‡é’ˆæ–¹å¼é«˜æ•ˆå®ç°ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240411115120025.png" alt="image-20240411115120025" style="zoom:33%;" />

ä½†è‹¥æ˜¯ç¬¦å·è¡¨å·¨å¤§ï¼Œå¤åˆ¶ä»ç„¶éœ€è¦è¾ƒå¤šçš„æ—¶é—´ï¼Œå¯ä»¥ä½¿ç”¨äºŒå‰æœç´¢æ ‘ä»£æ›¿å“ˆå¸Œè¡¨ä»¥åŠ é€Ÿå¤åˆ¶çš„è¿‡ç¨‹ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240411115338728.png" alt="image-20240411115338728" style="zoom:33%;" />

è¯­ä¹‰åˆ†æä¸­ä¸åœ¨ä¹å­—ç¬¦ä¸²æ˜¯å¦åŒ¹é…ï¼Œå¯ä»¥å°†å­—ç¬¦ä¸²è½¬åŒ–ä¸º symbol ä»¥åŠ é€Ÿ Hash æ“ä½œã€‚symbol å¯ä»¥ç›´æ¥ä½œä¸º hash keyï¼Œç”¨äºåŒ¹é…ï¼Œè¿˜å¯ä»¥åœ¨äºŒå‰æœç´¢æ ‘ä¸­ä½œä¸ºç´¢å¼•ã€‚

Tiger è¯­å¥ä¸­æœ‰ä¸¤ç§ç»‘å®šï¼šç±»å‹ç»‘å®š (Typedef)ã€å˜é‡ç»‘å®š

#### Type-checking ç±»å‹æ£€æŸ¥

å®é™…ä¸Šæ˜¯å¯¹äº AST çš„ä¸€ä¸ªé€’å½’éå†çš„è¿‡ç¨‹ã€‚

éœ€è¦è€ƒè™‘çš„æƒ…å†µæœ‰ï¼š

+ æ£€æŸ¥èµ‹å€¼çš„ç±»å‹æ˜¯å¦ä¸€è‡´ã€‚

+ å°†å‡½æ•°åä¸å…¶å‚æ•°è¡¨ä¸€å—æ”¾è¿› environmentã€‚

+ ç»“æ„ä½“ä¸­å­˜åœ¨å¤§é‡çš„é€’å½’å®šä¹‰ï¼š

  ~~~c
  struct temp {
      int a;
      struct temp tmp;
  }
  ~~~

  å¦‚æœç›´æ¥è¿›è¡Œæ£€æŸ¥ä¼šå‡ºç°æ­»é”çš„æƒ…å†µï¼Œæ­¤æ—¶å…ˆæ£€æŸ¥ç»“æ„ä½“ï¼Œä½¿ç”¨å ä½ç¬¦ (å¦‚ï¼šTy_Name) å…ˆä»£æ›¿ç±»å‹ã€‚æœ€åè¿›è¡Œå¤„ç†ã€‚

  ä½†å¦‚æœå­˜åœ¨ä¸‹è¿°çš„å¾ªç¯å®šä¹‰æƒ…å†µåˆ™ä¸å¯ï¼š

  ~~~c
  typedef a b;
  typedef b a;
  /*
  line1: a -> Ty_Name{a, bâ€™s Ty_Name}
         b -> Ty_Name{b, NULL}
  line2: b -> Ty_Name{b, aâ€™s Ty_Name}
  	   a -> Ty_Name{a, bâ€™s Ty_Name}
  */
  ~~~

  ä¼šå‡ºç°ç¯ï¼Œæ— æ³•è·å–å…·ä½“çš„ç±»å‹ã€‚ä½†ä¸‹è¿°çš„æƒ…å†µå¯ä»¥ï¼š

  ~~~c
  typedef a b;
  struct b {
      a i;
  }
  /*
  line1: a -> Ty_Name{a, bâ€™s Ty_Name}
         b -> Ty_Name{b, NULL}
  line2: b -> Ty_Name{b, Ty_Record}
  	   a -> Ty_Name{a, bâ€™s Ty_Name}
  */
  ~~~

  ç±»å‹æ£€æŸ¥ä¹Ÿéœ€è¦æ£€æŸ¥ç¯çš„æƒ…å†µã€‚

+ å¯¹äºå¾ªç¯å‡½æ•°é€’å½’è°ƒç”¨ï¼š

  ~~~c
  void f() {
      g();
  }
  void g() {
      f();
  }
  ~~~

  åªéœ€è¦å…ˆè®¡ç®—å‡ºä¸€è€…çš„è¿”å›å€¼å’Œç±»å‹ã€å‚æ•°è¡¨ç­‰å³å¯ã€‚



### Activation Records æ´»åŠ¨è®°å½•

> 2024.04.18

<img src="./ç¼–è¯‘åŸç†.assets/image-20240418104824491.png" alt="image-20240418104824491" style="zoom:30%;" />

æ­¤ç« èŠ‚ä¸»è¦å…³å¿ƒ stackï¼šdata structures called **activation records** that get generated during procedure (i.e. function) calls.

+ Procedure (i.e., function) calls and returns are usually managed by a run-time stack called *control stack*.

+ Each time a procedure is called, space for its local variables is pushed onto the stack.

+ When the procedure terminates, that space is popped off the stack.

+ Procedure calls are also called activations of procedures.

+ Each live activation has an *activation record* (sometimes called a *frame*) on the control stack.

ä½†è‹¥å¯ä»¥åŒæ—¶å‡ºç° nested function å’Œ functio-valued variables (e.g. å‡½æ•°æŒ‡é’ˆ)ï¼Œæ ˆè¿™ç§ç±»å‹çš„æ•°æ®ç»“æ„å°±ä¸å¤Ÿç”¨äº†ã€‚

~~~js
fun f(x) =
  let fun g(y) = x+y 
    in g 
  end
 
val h = f(3) 
val j = f(4)
 
val z = h(5) 
val w = j(7)
~~~

#### Stack frame

> Local variables are pushed/popped in large batches
>
> Local variables are not always initialized right after their creation
>
> We want to continue accessing variables deep within the stack

æ‰€ä»¥éœ€è¦å°†æ ˆè§†ä¸ºæ•°ç»„ï¼Œå¯ä»¥è®¿é—®éæ ˆé¡¶çš„å…ƒç´ ã€‚

æ­¤å¤–è¿˜ç»´æŠ¤äº†ä¸€ä¸ª Stack pointerã€‚

<img src="./ç¼–è¯‘åŸç†.assets/image-20240418111025073.png" alt="image-20240418111025073" style="zoom:33%;" />

å…·ä½“çš„è®¾è®¡å¦‚ä¸‹ï¼š

<img src="./ç¼–è¯‘åŸç†.assets/image-20240418112212377.png" alt="image-20240418112212377" style="zoom:29%;" />

å…¶ä¸­ previous frame ä¸º caller å‡½æ•°ï¼Œcurrent frame ä¸º callee å‡½æ•°ã€‚

`incoming arguments`: passed by the caller

`outgoing arguments`: pass parameters to other functions

å¯ä»¥çœ‹åˆ°å‚æ•°æ˜¯ä»¥å€’åºå‹åœ¨æ ˆä¸­çš„ï¼Œè¿™æ˜¯ä¸ºäº†æé«˜æŒ‡é’ˆæŸ¥è¯¢çš„æ•ˆç‡ã€‚

é’ˆå¯¹äºä¹‹å‰æåˆ°çš„å‡½æ•°åµŒå¥—ç­‰é—®é¢˜ï¼Œæ­¤å¤„é€šè¿‡ `static link` æ¥è¿›è¡Œæ ˆå¸§ä¸æ ˆå¸§ä¹‹é—´çš„è¿æ¥ã€‚

å¯ä»¥çœ‹åˆ°é™¤äº†æ ˆæŒ‡é’ˆå¤–è¿˜ç»´æŠ¤äº†ä¸€ä¸ªå¸§æŒ‡é’ˆã€‚åœ¨è°ƒç”¨æ–°å‡½æ•°æ—¶ï¼Œä¼šè®°å½•ä¸‹è€ FP çš„ä½ç½®ï¼Œä»¥ä¾¿å›é€€ã€‚

è¿™ç§åŒæŒ‡é’ˆçš„æ–¹å¼å¯¹äºéè¿ç»­å†…å­˜æ’å¸ƒæˆ–å¸§å¤§å°å¯å˜ç­‰æƒ…å†µä¼šè¾ƒä¸ºæœ‰æ•ˆã€‚

å¯¹äºä¼ å‚ï¼Œç”±äºå¯„å­˜å™¨çš„æ•°é‡æœ‰é™ï¼Œä¸€èˆ¬æƒ…å†µä¸‹åªæœ‰å‰ k ä¸ªå‚æ•°é€šè¿‡å¯„å­˜å™¨è¿›è¡Œä¼ å‚ï¼Œå‰©ä¸‹çš„å‚æ•°é€šè¿‡å†…å­˜ä¼ é€’ã€‚ä½†éœ€è¦æ³¨æ„åˆ°ç”±äºä½¿ç”¨äº†å¯„å­˜å™¨è¿›è¡Œä¼ å‚ï¼Œéœ€è¦å°†ä¹‹å‰çš„å¯„å­˜å™¨éƒ½å­˜è¿›å†…å­˜ï¼Œä¼¼ä¹ä¼šæ‹–æ…¢æ€§èƒ½ã€‚ä½¿ç”¨å¯„å­˜å™¨ä¼ å‚åœ¨ä»¥ä¸‹çš„å‡ ä¸ªæƒ…å†µæœ‰æ•ˆï¼š

1. Leaf procedures need not write their incoming arguments to memory.
   + **leaf** **procedures**: the procedures that don't call other procedures

2. Some optimizing compilers use **interprocedural register allocation**, analyzing all the functions in an entire program at once.
   + They assign different procedures different registers to receive parameters and hold local variables

3. Parameter x is a dead variable at the point where h(z) is called. Then f(x) can overwrite r1 without saving it.

4. Some architectures have register windows, so that each function invocation can allocate a fresh set of registers without memory traffic.

éƒ¨åˆ†æ¶æ„ä¸ä¼šå°†å¯„å­˜å™¨æ”¾åœ¨æ ˆå¸§ä¸­ï¼Œä¼šæ”¾åœ¨æŒ‡å®šçš„å¯„å­˜å™¨ä¸­ã€‚é’ˆå¯¹å¶å­è¿›ç¨‹å¯ä»¥ä½¿ç”¨ interprocedural register allocation è¿›è¡Œä¼˜åŒ–ã€‚

#### Static Link

+ **Block** **Structure**: In languages allowing nested function declarations (such as Pascal, ML, and Tiger), the inner functions may use variables declared in outer functions.

~~~js
type tree = {key: string, left: tree, right: tree}
function prettyprint(tree: tree) : string =
  let
    var output := â€œâ€  
    function write(s: string) = 
      output := concat(output,s)

    function show(n: int, t: tree) =
      let function indent(s: string) =
            (for i := 1 to n
             do write(â€œ â€));
             output := concat(output, s);
             write("\n"))
      in if t=nil 
         then indent(".")
         else (indent(t.key));
               show(n+1, t.left);
               show(n+1, t.right))
      end
    in show(0, tree); output
  end
~~~

æ­¤å¤„ä¾‹å¦‚ `write`  å‡½æ•°éœ€è¦èƒ½å¤Ÿè®¿é—® `prettyprint` çš„æ ˆå¸§ã€‚Tiger è¯­è¨€ä¸­éœ€è¦é€šè¿‡ static link æ¥å®ç° Block structureã€‚

`static link`ï¼šæ¯å½“å‡½æ•° f è¢«è°ƒç”¨æ—¶ï¼Œf ä¼šè¢«ä¼ é€’ä¸€ä¸ªæ ˆå¸§çš„æŒ‡é’ˆï¼ŒæŒ‡å‘åŒ…å« f çš„ä¸Šä¸€çº§å‡½æ•°ï¼Œæ”¾ç½®åœ¨ f çš„ static link çš„åŒºåŸŸã€‚å¦‚æœæ˜¯é€’å½’è°ƒç”¨åˆ™ä¼ å…¥è‡ªå·±çš„ static linkã€‚

ä¸Šè¿°ä»£ç è¯¦ç»†çš„å¤„ç†è¿‡ç¨‹å¦‚ä¸‹ï¼š

+ `in show(0, tree); output`  

  + passing pretryprint's own frame pointer (FP) as show's static link: prettyprint is the immediate enclosing function of show
  + show's static link = prettyprint's FP

+ `function show(n:int, t: tree) =`

  + show stores its static link (the address of prettyprint's FP)

+ `then indent(".")`

  + show calls indent, passing its own **FP** as indent's static link

+ ` show(n+1, t.left)`

  + show calls show, passing its own **static** **link** (not its own FP) as the static link

+ `for i := 1 to n`

  + fetch n at an appropriate offset from indent's static link (which points at the frame of show)

+ `write("\n")`

  + indent's static link (show's FP) + offset = show's static link = prettyprint's FP

  + **How** **can** **indent** **use** **output** **from** **prettyprint's** **frame?**

    It starts with its own static link, then fetches show's, then fetches output.
